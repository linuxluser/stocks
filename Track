#!/usr/bin/env python3

"""Track is a utility to track stock positions and interests.

Subcommands:
 - buy         Buy a stock
 - sell        Sell a stock
 - positions   Display current positions
 - watch       Add a stock to the watch list
 - unwatch     Remove a stock from the watch list
 - watchlist   Display the watch list
 - history     Display the history
 - pick        Add a stock to the picklist
 - unpick      Remove a stock from the watch list
 - picklist    Display the pick list
 - today       Show today's plan
"""

import argparse
import datetime
import dbm
import os
import pathlib
import shelve
import string
import sys
import time

from sh import at
from sh import atrm

import colors
import fetcher


class Error(Exception):
  """Base error class."""


class BadTickerFormError(Error):
  """Ticker is not in correct form."""


class EntryExistsError(Error):
  """Entry already exists."""


class EntryDoesNotExistError(Error):
  """Entry does not exists."""


class Datastore(object):
  """The local datastore of all program information."""

  DEFAULT_DIRECTORY = os.path.join(str(pathlib.Path.home()), '.stock_tracker')

  def __init__(self, base=DEFAULT_DIRECTORY):
    if not os.path.exists(base):
      os.makedirs(base)
    databases = ('history',
                 'watchlist',
                 'picklist',
                 'positions')

    # set database filename attr
    for db in databases:
      setattr(self, '_{}_file'.format(db), os.path.join(base, db))

    # define getters that return dict copies of the databases
    for db in databases:
      setattr(self, 'get_{}'.format(db), self.__make_getter(db))

    self.data_fetcher = fetcher.DataFetcher()

  def __make_getter(self, db):
    """Makes a getter method for a specific database."""
    filename = getattr(self, '_{}_file'.format(db))
    def fn():
      with shelve.open(filename) as db:
        return dict(db)
    return fn

  def _get_OHLCV(self, ticker):
    df = self.data_fetcher.FetchData(ticker).tail(1)
    return {'open': float(df[fetcher.DataSource.OPEN]),
            'high': float(df[fetcher.DataSource.HIGH]),
            'low': float(df[fetcher.DataSource.LOW]),
            'close': float(df[fetcher.DataSource.CLOSE]),
            'volume': float(df[fetcher.DataSource.VOLUME])}


  def _add_history_record(self, ticker, *args):
    record = (now_tuple(),) + args
    with shelve.open(self._history_file) as history:
      if ticker not in history:
        history[ticker] = [record]
      else:
        history[ticker] += [record]

  def _remove_from_picklist_in_future(self, ticker, hours):
    """Use the system 'at' command to run 'unpick' at a future time."""
    job_id = None
    script = os.path.abspath(__file__)
    cmd = '{} unpick {}'.format(script, ticker)
    when = 'now + {} hours'.format(hours)
    for line in at(when, _in=cmd, _iter=True, _err_to_out=True):
      if job_id is None and 'job' in line:
        words = line.split()
        job_id = int(words[words.index('job') + 1]) # next word after 'job'
    return job_id

  def _cancel_future_removal_from_picklist(self, at_job_id):
    atrm(at_job_id)

  def _add_position(self, sale_type, ticker, shares, price):
    with shelve.open(self._positions_file) as positions:
      p = positions.setdefault(ticker, {'buys': [], 'sells': []})
      p[sale_type + 's'].append((shares, price))
      positions[ticker] = p
    self._add_history_record(ticker, sale_type, shares, price)

  def add_buy(self, ticker, shares, price):
    self._add_position('buy', ticker, shares, price)

  def add_sell(self, ticker, shares, price):
    self._add_position('sell', ticker, shares, price)

  def get_ticker_position_summary(self, ticker):
    with shelve.open(self._positions_file) as positions:
      pos = positions[ticker]
      return self.calc_position_summary(ticker, pos)

  def calc_position_summary(self, ticker, pos):
    bought = sum(a for a,_ in pos['buys'])
    sold = sum(a for a,_ in pos['sells'])
    holding = bought - sold
    avg = sum(p for _,p in pos['buys'])/len(pos['buys'])
    return {'holding': holding, 'average_price': avg, 'bought': bought, 'sold': sold}

  def add_to_watchlist(self, ticker, note):
    with shelve.open(self._watchlist_file) as watchlist:
      if ticker in watchlist:
        raise EntryExistsError('{} already in watchlist'.format(ticker))
      watchlist[ticker] = {'note': note,
                           'timestamp': now_tuple(),
                           'prices': self._get_OHLCV(ticker)}
    self._add_history_record(ticker, 'watch', note)

  def remove_from_watchlist(self, ticker):
    with shelve.open(self._watchlist_file) as watchlist:
      if ticker not in watchlist:
        raise EntryDoesNotExistError('{} not in watchlist'.format(ticker))
      del watchlist[ticker]
    self._add_history_record(ticker, 'unwatch')

  def add_to_picklist(self, ticker, note):
    with shelve.open(self._picklist_file) as picklist:
      if ticker in picklist:
        raise EntryExistsError('{} already in picklist'.format(ticker))
      at_job_id = self._remove_from_picklist_in_future(ticker, 24)
      picklist[ticker] = {'note': note,
                          'at_job_id': at_job_id,
                          'timestamp': now_tuple(),
                          'prices': self._get_OHLCV(ticker)}
    self._add_history_record(ticker, 'pick', note)

  def remove_from_picklist(self, ticker):
    with shelve.open(self._picklist_file) as picklist:
      if ticker not in picklist:
        raise EntryDoesNotExistError('{} not in picklist'.format(ticker))
      self._cancel_future_removal_from_picklist(picklist[ticker]['at_job_id'])
      del picklist[ticker]
    self._add_history_record(ticker, 'unpick')


class CommandDispatcher(object):
  """Performs the high-level function of each subcommand."""

  def __init__(self, datastore):
    self.datastore = datastore

  def _print_summary(self, ticker, summary):
    print('{}:'.format(ticker))
    print('  {holding} @{average_price:.2f} (avg); '.format(**summary), end='')
    print('bought: {bought}, sold: {sold}'.format(**summary))

  def _print_current_positions(self):
    for ticker, pos in self.datastore.get_positions().items():
      summary = self.datastore.calc_position_summary(ticker, pos)
      self._print_summary(ticker, summary)

  def _print_ticker_summary(self, ticker):
    summary = self.datastore.get_ticker_position_summary(ticker)
    self._print_summary(ticker, summary)

  def _print_anylist(self, name, highlights, highlight_color):
    highlight_all = '*' in highlights
    getter = getattr(self.datastore, 'get_{}list'.format(name))
    headers = ['TICKER', 'NOTE', 'AGE', 'PRICE (then)']
    items = [(i[1]['timestamp'], i) for i in getter().items()]
    items.sort(reverse=True)
    rows = []
    for timestamp, (ticker, data) in items:
      age = timestamp_age_string(timestamp)
      rows.append((ticker, data['note'] or '', age, data['prices']['close']))
    TabularPrinter(headers).print(rows, price_columns=[4], indent=4)

  def _print_watchlist(self, highlights=[], highlight_color=colors.GREEN):
    return self._print_anylist('watch', highlights, highlight_color)

  def _print_picklist(self, highlights=[], highlight_color=colors.GREEN):
    return self._print_anylist('pick', highlights, highlight_color)

  def _print_history(self):
    for ticker,recs in self.datastore.get_history().items():
      for rec in recs:
        tt = rec[0]
        print('{}\t{}'.format(ticker, rec))

  def _print_todays_plan(self, picklist_color=colors.GREEN, watchlist_color=colors.CYAN):
    print(colors.Paint('[PICKLIST]', picklist_color))
    self._print_picklist(highlights=['*'], highlight_color=picklist_color)
    print(colors.Paint('\n[WATCHLIST]', watchlist_color))
    self._print_watchlist(highlights=['*'], highlight_color=watchlist_color)

  def buy(self, ticker, shares, price, **ignored):
    self.datastore.add_buy(ticker, shares, price)
    self._print_ticker_summary(ticker)
  b = buy  # to respond to alias

  def sell(self, ticker, shares, price, **ignored):
    self.datastore.add_sell(ticker, shares, price)
    self._print_ticker_summary(ticker)
  s = sell  # to respond to alias

  def positions(self, **ignored):
    self._print_current_positions()

  def watch(self, tickers, note='', **ignored):
    for ticker in tickers:
      self.datastore.add_to_watchlist(ticker, note)
    self._print_watchlist(tickers)
  w = watch  # to respond to alias

  def unwatch(self, tickers, **ignored):
    for ticker in tickers:
      self.datastore.remove_from_watchlist(ticker)
    self._print_watchlist()

  def watchlist(self, **ignored):
    self._print_watchlist()

  def pick(self, tickers, note='', **ignored):
    for ticker in tickers:
      self.datastore.add_to_picklist(ticker, note)
    self._print_picklist(tickers)
  p = pick  # to respond to alias

  def unpick(self, tickers, **ignored):
    for ticker in tickers:
      self.datastore.remove_from_picklist(ticker)
    self._print_picklist()

  def picklist(self, **ignored):
    self._print_picklist()

  def history(self, **ignored):
    self._print_history()

  def today(self, **ignored):
    self._print_todays_plan()


class TabularPrinter(object):

  def __init__(self, headers):
    self.headers = headers

  def _calc_max_widths(self, rows):
    """Calculate max widths of each column."""
    num_cols = len(self.headers)
    widths = [len(h) for h in self.headers]
    for row in rows:
      if len(row) != num_cols:
        raise ValueError('headers and row lengths must be the same')
      for i, val in enumerate(row):
        length = len(str(val))
        if length > widths[i]:
          widths[i] = length
    return widths

  def _collate(self, row, widths):
    """Collate the row value along with its width to get format() args."""
    return [t for tup in zip(row, widths) for t in tup]

  def _mkformat(self, sep, price_columns):
    """Create a format string with given separator."""
    columns = ['{:<{}}']*len(self.headers)
    for c in price_columns:
      columns[c -1] = '{:<{}.2f}'
    return sep.join(columns)

  def _print_headers(self, widths, indent):
    space_fmt = self._mkformat('   ', [])
    bar_fmt = self._mkformat('-|-', [])
    dashes = ('-'*widths[i] for i,_ in enumerate(self.headers))
    print(' '*indent, end='')
    print(space_fmt.format(*self._collate(self.headers, widths)))
    print(' '*indent, end='')
    print(bar_fmt.format(*self._collate(dashes, widths)))

  def _print_rows(self, widths, rows, price_columns, indent):
    fmt = self._mkformat('   ', price_columns)
    for row in rows:
      print(' '*indent, end='')
      print(fmt.format(*self._collate(row, widths)))

  def print(self, rows, price_columns=[], indent=0):
    if not rows:
      return
    widths = self._calc_max_widths(rows)
    self._print_headers(widths, indent)
    self._print_rows(widths, rows, price_columns, indent)


def is_ticker(ticker):
  return all(c in string.ascii_uppercase for c in ticker)


def valid_ticker(ticker):
  """Determines if this string is a valid ticker and throw an exception if not.

  This is used as the type= argument to some argparse args as a quick and
  dirty way to validate arguments.
  """
  if not is_ticker(ticker):
    raise BadTickerFormError('"{}" is not a ticker'.format(ticker))
  return ticker


def now_tuple():
  """Get the current datetime as a time-tuple."""
  return tuple(datetime.datetime.now().utctimetuple())


def timestamp_age_string(timestamp):
  """Convert a time-tuple to a human-friendly format."""
  now = datetime.datetime.now()
  then = datetime.datetime(*timestamp[:7])
  delta = now - then
  days = delta.days
  hours = int((delta.total_seconds() / 60.0 / 60.0) % 24)
  minutes = int((delta.total_seconds() / 60.0) % 60)
  if days == hours == 0:
    return '{} mins ago'.format(minutes)
  if days == 0:
    return '{}h {}m ago'.format(hours, minutes)
  return '{} days, {}:{} ago'.format(days, hours, minutes)


def main(args):
  dispatcher = CommandDispatcher(Datastore())
  getattr(dispatcher, args.command)(**vars(args))


if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  subcommands = parser.add_subparsers(title='Subcommands', dest='command')

  # buy
  parser_buy = subcommands.add_parser('buy', aliases=['b'], help='Buy a stock')
  parser_buy.add_argument('ticker')
  parser_buy.add_argument('shares', type=int)
  parser_buy.add_argument('price', type=float)

  # sell
  parser_sell = subcommands.add_parser('sell', aliases=['s'], help='Sell a stock')
  parser_sell.add_argument('ticker')
  parser_sell.add_argument('shares', type=int)
  parser_sell.add_argument('price', type=float)

  # positions
  parser_positions = subcommands.add_parser('positions', help='Display current positions')

  # watch
  parser_watch = subcommands.add_parser('watch', aliases=['w'], help='Add stocks to the watch list')
  parser_watch.add_argument('tickers', nargs='+', type=valid_ticker)
  parser_watch.add_argument('-n', '--note', help='')

  # unwatch
  parser_unwatch = subcommands.add_parser('unwatch', help='Remove a stock from the watch list')
  parser_unwatch.add_argument('tickers', nargs='+', type=valid_ticker)

  # watchlist
  parser_watchlist = subcommands.add_parser('watchlist', help='Display the watch list')

  # history
  parser_history = subcommands.add_parser('history', help='Display the history')

  # pick
  parser_pick = subcommands.add_parser('pick', aliases=['p'], help='Add stocks to the picklist')
  parser_pick.add_argument('tickers', nargs='+', type=valid_ticker)
  parser_pick.add_argument('-n', '--note', help='')

  # unpick
  parser_unpick = subcommands.add_parser('unpick', help='Remove a stock from the watch list')
  parser_unpick.add_argument('tickers', nargs='+', type=valid_ticker)

  # picklist
  parser_picklist = subcommands.add_parser('picklist', help='Display the pick list')

  # today
  parser_today = subcommands.add_parser('today', help='Show today\'s plan')

  args = parser.parse_args()
  if args.command == None:
    args.command = 'today'
  main(args)
