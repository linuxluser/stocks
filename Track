#!/usr/bin/env python3

"""Track is a utility to track stock positions and interests.

Subcommands:
 - buy         Buy a stock
 - sell        Sell a stock
 - positions   Display current positions
 - watch       Add a stock to the watch list
 - unwatch     Remove a stock from the watch list
 - watchlist   Display the watch list
 - history     Display the history
 - pick        Add a stock to the picklist
 - unpick      Remove a stock from the watch list
 - picklist    Display the pick list
 - listall     Show all lists
"""

import argparse
import datetime
import dbm
import os
import pathlib
import shelve
import string
import sys
import time

from sh import at
from sh import atrm

import colors
import fetcher


class Error(Exception):
  """Base error class."""


class BadTickerFormError(Error):
  """Ticker is not in correct form."""


class EntryExistsError(Error):
  """Entry already exists."""


class EntryDoesNotExistError(Error):
  """Entry does not exists."""


class Datastore(object):
  """The local datastore of all program information."""

  DEFAULT_DIRECTORY = os.path.join(str(pathlib.Path.home()), '.stock_tracker')

  def __init__(self, base=DEFAULT_DIRECTORY):
    if not os.path.exists(base):
      os.makedirs(base)
    databases = ('history',
                 'watchlist',
                 'picklist',
                 'positions')

    # set database filename attr
    for db in databases:
      setattr(self, '_{}_file'.format(db), os.path.join(base, db))

    # define getters that return dict copies of the databases
    for db in databases:
      setattr(self, 'get_{}'.format(db), self.__make_getter(db))

  def __make_getter(self, db):
    """Makes a getter method for a specific database."""
    filename = getattr(self, '_{}_file'.format(db))
    def fn():
      with shelve.open(filename) as db:
        return dict(db)
    return fn

  def _add_history_record(self, ticker, *args):
    record = (now_tuple(),) + args
    with shelve.open(self._history_file) as history:
      if ticker not in history:
        history[ticker] = [record]
      else:
        history[ticker] += [record]

  def _remove_from_picklist_in_future(self, ticker, hours):
    """Use the system 'at' command to run 'unpick' at a future time."""
    job_id = None
    script = os.path.abspath(__file__)
    cmd = '{} unpick {}'.format(script, ticker)
    when = 'now + {} hours'.format(hours)
    for line in at(when, _in=cmd, _iter=True, _err_to_out=True):
      if job_id is None and 'job' in line:
        words = line.split()
        job_id = int(words[words.index('job') + 1]) # next word after 'job'
    return job_id

  def _cancel_future_removal_from_picklist(self, at_job_id):
    atrm(at_job_id)

  def _add_position(self, sale_type, ticker, shares, price):
    with shelve.open(self._positions_file) as positions:
      p = positions.setdefault(ticker, {'transactions': []})
      p['transactions'].append((now_tuple(), sale_type, shares, price))
      positions[ticker] = p
    self._add_history_record(ticker, sale_type, shares, price)

  def _calc_position_summary(self, ticker, pos):
    trans = pos['transactions']
    buy_trans = [t for t in trans if t[1] == 'buy']
    sell_trans = [t for t in trans if t[1] == 'sell']
    bought = sum(t[2] for t in buy_trans)
    sold = sum(t[2] for t in sell_trans)
    holding = bought - sold
    avg = sum(t[3] for t in buy_trans)/len(buy_trans)
    return {'holding': holding, 'average_cost': avg, 'bought': bought, 'sold': sold}

  def update_position(self, ticker, **kwargs):
    with shelve.open(self._positions_file, writeback=True) as positions:
      if ticker not in positions:
        raise EntryDoesNotExistError('No position for {}'.format(ticker))
      positions[ticker].update(kwargs)

  def add_buy(self, ticker, shares, price, **attrs):
    self._add_position('buy', ticker, shares, price)
    if attrs:
      self.update_position(ticker, **attrs)

  def add_sell(self, ticker, shares, price):
    self._add_position('sell', ticker, shares, price)

  def get_position_summary(self, ticker):
    with shelve.open(self._positions_file) as positions:
      return self._calc_position_summary(ticker, positions[ticker])

  def get_all_position_summaries(self):
    summaries = {}
    with shelve.open(self._positions_file) as positions:
      for ticker, pos in positions.items():
        summaries[ticker] = self._calc_position_summary(ticker, pos)
        summaries[ticker].update({'stoploss': pos.get('stoploss'),
                                  'takeprofit': pos.get('takeprofit')})
    return summaries

  def add_to_watchlist(self, ticker, note):
    with shelve.open(self._watchlist_file) as watchlist:
      if ticker in watchlist:
        raise EntryExistsError('{} already in watchlist'.format(ticker))
      watchlist[ticker] = {'note': note,
                           'timestamp': now_tuple(),
                           'prices': get_OHLCV(ticker)}
    self._add_history_record(ticker, 'watch', note)

  def remove_from_watchlist(self, ticker):
    with shelve.open(self._watchlist_file) as watchlist:
      if ticker not in watchlist:
        raise EntryDoesNotExistError('{} not in watchlist'.format(ticker))
      del watchlist[ticker]
    self._add_history_record(ticker, 'unwatch')

  def add_to_picklist(self, ticker, note):
    with shelve.open(self._picklist_file) as picklist:
      if ticker in picklist:
        raise EntryExistsError('{} already in picklist'.format(ticker))
      at_job_id = self._remove_from_picklist_in_future(ticker, 24)
      picklist[ticker] = {'note': note,
                          'at_job_id': at_job_id,
                          'timestamp': now_tuple(),
                          'prices': get_OHLCV(ticker)}
    self._add_history_record(ticker, 'pick', note)

  def remove_from_picklist(self, ticker):
    with shelve.open(self._picklist_file) as picklist:
      if ticker not in picklist:
        raise EntryDoesNotExistError('{} not in picklist'.format(ticker))
      self._cancel_future_removal_from_picklist(picklist[ticker]['at_job_id'])
      del picklist[ticker]
    self._add_history_record(ticker, 'unpick')


class CommandDispatcher(object):
  """Performs the high-level function of each subcommand."""

  def __init__(self, datastore):
    self.datastore = datastore

  def _print_summary(self, ticker, summary):
    print('{}:'.format(ticker))
    print('  {holding} @{average_cost:.2f} (avg); '.format(**summary), end='')
    print('bought: {bought}, sold: {sold}'.format(**summary))

  def _make_position_scale(self, stoploss, price, takeprofit):
    p  = '{:.2f}'.format(price or 0.0)
    sl = tp = 'oo'  # "infinity" lol
    if stoploss:
      sl = '{:.2f}'.format(stoploss)
    if takeprofit:
      tp = '{:.2f}'.format(takeprofit)
    num_dashes = 30 - len(sl) - len(p) - len(tp)
    if not stoploss or not takeprofit:
      left = int(num_dashes/2)
      right = num_dashes - left
    else:
      total = takeprofit - stoploss
      percent_l = (price - stoploss) / total
      percent_r = (takeprofit - price) / total
      left = round(num_dashes * percent_l)
      right = round(num_dashes * percent_r)
    bar = '{}{}{}'.format('_'*left, p, '_'*right)
    return '{}{}{}'.format(sl, bar, tp)

  def _print_current_positions(self):
    summaries = self.datastore.get_all_position_summaries()
    #headers = ['TICKER', 'SHARES', 'AVG COST', 'GAIN/LOSS', 'STOPLOSS', 'TAKEPROFIT']
    headers = ['TICKER', 'SHARES', 'AVG COST', 'GAIN/LOSS', 'POSITION']
    rows = []
    for ticker, summary in summaries.items():
      current_price = get_OHLCV(ticker)['close']
      gain_loss = current_price - summary['average_cost']
      gain_loss_pct = (gain_loss / current_price) * 100.0
      stoploss, takeprofit = summary.get('stoploss'), summary.get('takeprofit')
      pos_scale = self._make_position_scale(stoploss, current_price, takeprofit)
      rows.append((ticker,
                   summary['holding'],
                   summary['average_cost'],
                   '{:.2f} ({:.2f}%)'.format(gain_loss, gain_loss_pct),
                   pos_scale))
    TabularPrinter(headers).print(rows, price_columns=[3], indent=4)

  def _print_ticker_summary(self, ticker):
    summary = self.datastore.get_position_summary(ticker)
    self._print_summary(ticker, summary)

  def _print_anylist(self, name, highlights, highlight_color):
    highlight_all = '*' in highlights
    getter = getattr(self.datastore, 'get_{}list'.format(name))
    headers = ['TICKER', 'NOTE', 'AGE', '{} PRICE'.format(name.upper())]
    items = [(i[1]['timestamp'], i) for i in getter().items()]
    items.sort(reverse=True)
    rows = []
    for timestamp, (ticker, data) in items:
      age = timestamp_age_string(timestamp)
      rows.append((ticker, data['note'] or '', age, data['prices']['close']))
    TabularPrinter(headers).print(rows, price_columns=[4], indent=4)

  def _print_watchlist(self, highlights=[], highlight_color=colors.GREEN):
    return self._print_anylist('watch', highlights, highlight_color)

  def _print_picklist(self, highlights=[], highlight_color=colors.GREEN):
    return self._print_anylist('pick', highlights, highlight_color)

  def _print_history(self):
    for ticker,recs in self.datastore.get_history().items():
      for rec in recs:
        tt = rec[0]
        print('{}\t{}'.format(ticker, rec))

  def _print_all_lists(self, picklist_color=colors.GREEN,
                             positions_color=colors.BLUE,
                             watchlist_color=colors.CYAN):
    print(colors.Paint('[PICKLIST]', picklist_color))
    self._print_picklist(highlights=['*'], highlight_color=picklist_color)
    print(colors.Paint('\n[POSITIONS]', positions_color))
    self._print_current_positions()
    print(colors.Paint('\n[WATCHLIST]', watchlist_color))
    self._print_watchlist(highlights=['*'], highlight_color=watchlist_color)

  def buy(self, ticker, shares, price, **kwargs):
    # selectively pluck out attributes/flags from kwargs
    attrs = {}
    for attr in ('stoploss', 'takeprofit'):
      if attr in kwargs:
        attrs[attr] = kwargs[attr]
    self.datastore.add_buy(ticker, shares, price, **attrs)
    self._print_ticker_summary(ticker)
  b = buy  # to respond to alias

  def sell(self, ticker, shares, price, **ignored):
    self.datastore.add_sell(ticker, shares, price)
    self._print_ticker_summary(ticker)
  s = sell  # to respond to alias

  def positions(self, **ignored):
    self._print_current_positions()

  def stoploss(self, ticker, price, **ignored):
    self.datastore.update_position(ticker, stoploss=price)
    self._print_current_positions()

  def takeprofit(self, ticker, price, **ignored):
    self.datastore.update_position(ticker, takeprofit=price)
    self._print_current_positions()

  def watch(self, tickers, note='', **ignored):
    for ticker in tickers:
      self.datastore.add_to_watchlist(ticker, note)
    self._print_watchlist(tickers)
  w = watch  # to respond to alias

  def unwatch(self, tickers, **ignored):
    for ticker in tickers:
      self.datastore.remove_from_watchlist(ticker)
    self._print_watchlist()

  def watchlist(self, **ignored):
    self._print_watchlist()

  def pick(self, tickers, note='', **ignored):
    for ticker in tickers:
      self.datastore.add_to_picklist(ticker, note)
    self._print_picklist(tickers)
  p = pick  # to respond to alias

  def unpick(self, tickers, **ignored):
    for ticker in tickers:
      self.datastore.remove_from_picklist(ticker)
    self._print_picklist()

  def picklist(self, **ignored):
    self._print_picklist()

  def history(self, **ignored):
    self._print_history()

  def listall(self, **ignored):
    self._print_all_lists()


class TabularPrinter(object):

  def __init__(self, headers):
    self.headers = headers

  def _calc_max_widths(self, rows, price_columns):
    """Calculate max widths of each column."""
    num_cols = len(self.headers)
    widths = [len(h) for h in self.headers]
    for row in rows:
      if len(row) != num_cols:
        raise ValueError('headers and row lengths must be the same')
      for i, val in enumerate(row):
        if i+1 in price_columns:
          length = len('{:.2f}'.format(val))
        else:
          length = len(str(val))
        if length > widths[i]:
          widths[i] = length
    return widths

  def _collate(self, row, widths):
    """Collate the row value along with its width to get format() args."""
    return [t for tup in zip(row, widths) for t in tup]

  def _mkformat(self, sep, price_columns):
    """Create a format string with given separator."""
    columns = ['{:<{}}']*len(self.headers)
    for c in price_columns:
      columns[c -1] = '{:<{}.2f}'
    return sep.join(columns)

  def _print_headers(self, widths, indent):
    space_fmt = self._mkformat('   ', [])
    bar_fmt = self._mkformat('-|-', [])
    dashes = ('-'*widths[i] for i,_ in enumerate(self.headers))
    print(' '*indent, end='')
    print(space_fmt.format(*self._collate(self.headers, widths)))
    print(' '*indent, end='')
    print(bar_fmt.format(*self._collate(dashes, widths)))

  def _print_rows(self, widths, rows, price_columns, indent):
    fmt = self._mkformat('   ', price_columns)
    for row in rows:
      print(' '*indent, end='')
      print(fmt.format(*self._collate(row, widths)))

  def print(self, rows, price_columns=[], indent=0):
    if not rows:
      return
    widths = self._calc_max_widths(rows, price_columns)
    self._print_headers(widths, indent)
    self._print_rows(widths, rows, price_columns, indent)


def is_ticker(ticker):
  return all(c in string.ascii_uppercase for c in ticker)


def valid_ticker(ticker):
  """Determines if this string is a valid ticker and throw an exception if not.

  This is used as the type= argument to some argparse args as a quick and
  dirty way to validate arguments.
  """
  if not is_ticker(ticker):
    raise BadTickerFormError('"{}" is not a ticker'.format(ticker))
  return ticker


def now_tuple():
  """Get the current datetime as a time-tuple."""
  return tuple(datetime.datetime.now().utctimetuple())


def timestamp_age_string(timestamp):
  """Convert a time-tuple to a human-friendly format."""
  now = datetime.datetime.now()
  then = datetime.datetime(*timestamp[:7])
  delta = now - then
  days = delta.days
  hours = int((delta.total_seconds() / 60.0 / 60.0) % 24)
  minutes = int((delta.total_seconds() / 60.0) % 60)
  if days == hours == 0:
    return '{} mins ago'.format(minutes)
  if days == 0:
    return '{}h {}m ago'.format(hours, minutes)
  return '{} days, {}:{} ago'.format(days, hours, minutes)


def get_OHLCV(ticker):
  df = fetcher.DataFetcher().FetchData(ticker).tail(1)
  return {'open': float(df[fetcher.DataSource.OPEN]),
          'high': float(df[fetcher.DataSource.HIGH]),
          'low': float(df[fetcher.DataSource.LOW]),
          'close': float(df[fetcher.DataSource.CLOSE]),
          'volume': float(df[fetcher.DataSource.VOLUME])}


def main(args):
  dispatcher = CommandDispatcher(Datastore())
  getattr(dispatcher, args.command)(**vars(args))


if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  subcommands = parser.add_subparsers(title='Subcommands', dest='command')

  # buy
  parser_buy = subcommands.add_parser('buy', aliases=['b'], help='Buy a stock')
  parser_buy.add_argument('ticker')
  parser_buy.add_argument('shares', type=int)
  parser_buy.add_argument('price', type=float)
  parser_buy.add_argument('-s', '--stoploss', type=float, help='Stop-loss price.')
  parser_buy.add_argument('-t', '--takeprofit', type=float, help='Take-profit price.')

  # sell
  parser_sell = subcommands.add_parser('sell', aliases=['s'], help='Sell a stock')
  parser_sell.add_argument('ticker')
  parser_sell.add_argument('shares', type=int)
  parser_sell.add_argument('price', type=float)

  # stoploss
  parser_stoploss = subcommands.add_parser('stoploss', help='Set the stoploss price for a position')
  parser_stoploss.add_argument('ticker')
  parser_stoploss.add_argument('price', type=float)

  # takeprofit
  parser_takeprofit = subcommands.add_parser('takeprofit', help='Set the takeprofit price for a position')
  parser_takeprofit.add_argument('ticker')
  parser_takeprofit.add_argument('price', type=float)

  # positions
  parser_positions = subcommands.add_parser('positions', help='Display current positions')

  # watch
  parser_watch = subcommands.add_parser('watch', aliases=['w'], help='Add stocks to the watch list')
  parser_watch.add_argument('tickers', nargs='+', type=valid_ticker)
  parser_watch.add_argument('-n', '--note', help='')

  # unwatch
  parser_unwatch = subcommands.add_parser('unwatch', help='Remove a stock from the watch list')
  parser_unwatch.add_argument('tickers', nargs='+', type=valid_ticker)

  # watchlist
  parser_watchlist = subcommands.add_parser('watchlist', help='Display the watch list')

  # history
  parser_history = subcommands.add_parser('history', help='Display the history')

  # pick
  parser_pick = subcommands.add_parser('pick', aliases=['p'], help='Add stocks to the picklist')
  parser_pick.add_argument('tickers', nargs='+', type=valid_ticker)
  parser_pick.add_argument('-n', '--note', help='')

  # unpick
  parser_unpick = subcommands.add_parser('unpick', help='Remove a stock from the watch list')
  parser_unpick.add_argument('tickers', nargs='+', type=valid_ticker)

  # picklist
  parser_picklist = subcommands.add_parser('picklist', help='Display the pick list')

  # listall
  parser_listall = subcommands.add_parser('listall', help='Show all lists')

  args = parser.parse_args()
  if args.command == None:
    args.command = 'listall'
  main(args)
